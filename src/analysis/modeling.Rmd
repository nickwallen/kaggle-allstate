```{r, include=FALSE}

library (data.table)
library (ggplot2)
library (reshape2)
library (lubridate)
library (stringr)

source ("../R/fetch.R")
source ("../R/features.R")
source ("../R/models.R")
source ("../R/score.R")
source ("../R/utils.R")

# set global options for all code chunks
opts_chunk$set(fig.width=12, fig.height=8, tidy=T)
```

Kaggle Allstate Purchase Prediction Competition
========================================================

Contains analysis around modeling for the Kaggle Allstate competition.

### Q. What would a naive model look like in this case?

A naive model would simply predict the most popular choice for each option.

```{r}

# fetch the training data
train <- fetch()

# train the naive model
model <- naive.model (train)

# make predictions 
train [, options.hat() := predict (model, .SD), with = F]
```

Notice how different the outcomes from each scoring mechanism is.  The Naive Model does tremendously better when scoring based on the number of correct options.

```{r}
accuracy.score (train)
partial.accuracy.score (train)
```

