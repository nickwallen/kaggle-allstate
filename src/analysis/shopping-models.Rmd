```{r, include=FALSE}

library (data.table)
library (ggplot2)
library (reshape2)
library (lubridate)
library (stringr)
library (caret)

source ("../R/fetch.R")
source ("../R/features.R")
source ("../R/shopping-models.R")
source ("../R/score.R")
source ("../R/utils.R")
source ("../R/cache.R")

# set global options for all code chunks
opts_chunk$set(fig.width=12, fig.height=8, tidy=T)
```

Modeling of Customer Shopping History
========================================================

The customer demographic data and the customer shopping history are completely different types of data.  We are going to model each of these independently.  The final prediction will be an ensemble between the two.  The initial challenge for the shopping history data is in flattening a customer's shopping history into one single record that can be used to train and predict the customer's final purchase plan.  

### Preprocessing

The input shopping data looks like the following.

| customer.id | shopping.pnt | record.type | day.of.week | time.of.day.hours | option.a | option.b | ... |
| ----------- | ------------ | ----------- | ----------- | ----------------- | -------- | -------- | ----|                                                 
| 123456789   | 1            | shopping    | Mon         | 2.25              | 0        | 1        |     |
| 123456789   | 2            | shopping    | Mon         | 3.25              | 0        | 1        |     |
| 123456789   | 3            | shopping    | Mon         | 3.50              | 1        | 2        |     |
| 123456789   | 4            | shopping    | Mon         | 4.00              | 1        | 2        |     |
| 123456789   | 5            | shopping    | Mon         | 5.00              | 0        | 2        |     |
| 123456789   | 6            | purchase    | Mon         | 6.26              | 0        | 2        |     |
| 000000001   | 1            | shopping    | Tue         | 2.25              | 0        | 1        |     |
| 000000001   | 2            | shopping    | Tue         | 3.25              | 0        | 1        |     |
| 000000001   | 3            | purchase    | Tue         | 3.50              | 1        | 2        |     |

The input data could be transformed as follows for training and prediction.

| customer.id | option.a.0 | option.a.1 | option.a.2 | option.b.0 | option.b.1 | option.a | option.b | ... | 
| ----------- | ---------- | ---------- | ---------- | ---------- | ---------- | -------- | -------- | --- |
| 123456789   | 3          | 2          | 0          | 2          | 2          | 0        | 2        |     |
| 000000001   | 2          | 0          | 0          | 0          | 2          | 1        | 2        |     |

The definition for each of these fields is as follows.

| Field         | Definition 
| ------------- | ---------- 
| *customer.id* | The customer's unique ID.  Each customer will have one record in training data.       
| *option.a.0*  | The total number of times the customer shopped for choice 0 of option A in the shopping history.
| *option.a.1*  | ...
| *option.a.2*  | ...
| *option.b.0*  | The total number of times the customer shopped for choice 0 of option A in the shopping history.
| *option.b.1*  | ...
| *option.a*    | The outcome for option a that is being predicted.  The value for this field comes from the purchase record.
| *option.b*    | ...

Does this work??  It does!  That wasy easy.

```{r}

# fetch the source data
data <- fetch()

# flatten the source into a form that can be used for training
shopping <- flatten.shopping.history (data)

# what do we have here?
str (shopping)
rm (data)
```

### Splitting

Split the data into a training and a hold-out test set.  Each set must be representative of the whole.  Use Caret's createDataPartition function for this.  Since this function requires a single outcome variable, create a 'Plan' representation of the options to allow it to do so.

```{r}

# use the 'product' attribute to split the data into representative test/train sets
add.plan (shopping)
train.index <- createDataPartition (shopping$plan, p = 0.8, list = F)[,1]

```

### Popular Model

Let's first look at a popular model.  The popular model simply chooses the option that has been shopped for by most
customers.  If a customer looks at the same option multiple times, then the option receives multiple votes.

```{r, results='hide'}

# create a train and test set
shopping.train <- shopping [  train.index ]
shopping.test  <- shopping [ -train.index ]

# train the naive model
fit <- popular.model (shopping.train)

# make predictions with the naive model
shopping.test [, options.hat() := predict (fit, .SD), with = F]

```

```{r}
# score the results
accuracy.score (shopping.test)
partial.accuracy.score (shopping.test)

```

### GBM Model

My first attempt will focus on modeling and training each of the options (a-g) independently.  There are far fewer models in R that can, or at least make it easy, to handle multiple output in my experience.  Since we have no knowledge of what each option actually is and each may be some what unrelated (auto liability versus umbrella coverage) modeling them separately will likely help (or at least not hurt).

Also, I am treating each option value as a numeric value rather than a factor.  Jacob is biz-snitch and not very confident in this approach. :/

```{r}

# create a train and test set
shopping.train <- shopping [  train.index ]
shopping.test  <- shopping [ -train.index ]

# trains the model - caches the results which can be time consuming to compute
gbm.fit.a <- cache ("gbm.fit.a", gbm.model ("option.a", shopping.train))
gbm.fit.b <- cache ("gbm.fit.b", gbm.model ("option.b", shopping.train))
gbm.fit.c <- cache ("gbm.fit.c", gbm.model ("option.c", shopping.train))
gbm.fit.d <- cache ("gbm.fit.d", gbm.model ("option.d", shopping.train))
gbm.fit.e <- cache ("gbm.fit.e", gbm.model ("option.e", shopping.train))
gbm.fit.f <- cache ("gbm.fit.f", gbm.model ("option.f", shopping.train))
gbm.fit.g <- cache ("gbm.fit.g", gbm.model ("option.g", shopping.train))
```

How did the parameter tuning go?

```{r}
ggplot(gbm.fit.a)
ggplot(gbm.fit.b)
ggplot(gbm.fit.c)
ggplot(gbm.fit.d)
ggplot(gbm.fit.e)
ggplot(gbm.fit.f)
ggplot(gbm.fit.g)
```

Which predictors are most important?  The results seem to show that a customer shopping for a particular option is indicative of what they will eventually purchase.  In addition it does not seem like the selection across option types has any significant impact.  For example, the selection of option A.1 does not impact E.2 or anything like that.

```{r}
plot (varImp (gbm.fit.a, scale = F), top = 10)
plot (varImp (gbm.fit.b, scale = F), top = 10)
plot (varImp (gbm.fit.c, scale = F), top = 10)
plot (varImp (gbm.fit.d, scale = F), top = 10)
plot (varImp (gbm.fit.e, scale = F), top = 10)
plot (varImp (gbm.fit.f, scale = F), top = 10)
plot (varImp (gbm.fit.g, scale = F), top = 10)
```

Make predictions with the various models.

```{r, results='hide'}

# make predictions with each model
shopping.test [, option.a.hat := round (predict (gbm.fit.a, .SD))]
shopping.test [, option.b.hat := round (predict (gbm.fit.b, .SD))]
shopping.test [, option.c.hat := round (predict (gbm.fit.c, .SD))]
shopping.test [, option.d.hat := round (predict (gbm.fit.d, .SD))]
shopping.test [, option.e.hat := round (predict (gbm.fit.e, .SD))]
shopping.test [, option.f.hat := round (predict (gbm.fit.f, .SD))]
shopping.test [, option.g.hat := round (predict (gbm.fit.g, .SD))]
```

```{r}
# score the results
accuracy.score (shopping.test)
partial.accuracy.score (shopping.test)
```

The first results show a very poor all-or-nothing accuracy of <1% of points;  effectively only 3 were predicted correctly in the entire test set.  This is far poorer than even the Kaggle Naive model which simply chooses the options which were last shopped for.  

### TODO

Perhaps a difference value for each of the 'option.x.n' fields could be used.  Perhaps ones that applies a greater weight to more recent shopping history.

### TODO 

Each option is currently being treated as a numeric.  What if we treated these as factors so that its truly a classification problem?  

### TODO 

This takes care of the option elements of the shopping history, but how should the additional date-related 'day.of.week' and 'time.of.day.hours' fields be leveraged in the analysis.







