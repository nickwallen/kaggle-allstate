```{r, include=FALSE}

library (data.table)
library (ggplot2)
library (reshape2)
library (lubridate)
library (stringr)
library (caret)

source ("../R/fetch.R")
source ("../R/features.R")
source ("../R/shopping-models.R")
source ("../R/score.R")
source ("../R/utils.R")

# set global options for all code chunks
opts_chunk$set(fig.width=12, fig.height=8, tidy=T)
```

Modeling of Customer Shopping History
========================================================

The customer demographic data and the customer shopping history are completely different types of data.  We are going to model each of these independently.  The final prediction will be an ensemble between the two.  The initial challenge for the shopping history data is in flattening a customer's shopping history into one single record that can be used to train and predict the customer's final purchase plan.  

### Preprocessing

The input shopping data looks like the following.

| customer.id | shopping.pnt | record.type | day.of.week | time.of.day.hours | option.a | option.b | ... |
| ----------- | ------------ | ----------- | ----------- | ----------------- | -------- | -------- | ----|                                                 
| 123456789   | 1            | shopping    | Mon         | 2.25              | 0        | 1        |     |
| 123456789   | 2            | shopping    | Mon         | 3.25              | 0        | 1        |     |
| 123456789   | 3            | shopping    | Mon         | 3.50              | 1        | 2        |     |
| 123456789   | 4            | shopping    | Mon         | 4.00              | 1        | 2        |     |
| 123456789   | 5            | shopping    | Mon         | 5.00              | 0        | 2        |     |
| 123456789   | 6            | purchase    | Mon         | 6.26              | 0        | 2        |     |
| 000000001   | 1            | shopping    | Tue         | 2.25              | 0        | 1        |     |
| 000000001   | 2            | shopping    | Tue         | 3.25              | 0        | 1        |     |
| 000000001   | 3            | purchase    | Tue         | 3.50              | 1        | 2        |     |

The input data could be transformed as follows for training and prediction.

| customer.id | option.a.0 | option.a.1 | option.a.2 | option.b.0 | option.b.1 | option.a | option.b | ... | 
| ----------- | ---------- | ---------- | ---------- | ---------- | ---------- | -------- | -------- | --- |
| 123456789   | 3          | 2          | 0          | 2          | 2          | 0        | 2        |     |
| 000000001   | 2          | 0          | 0          | 0          | 2          | 1        | 2        |     |

The definition for each of these fields is as follows.

| Field         | Definition 
| ------------- | ---------- 
| *customer.id* | The customer's unique ID.  Each customer will have one record in training data.       
| *option.a.0*  | The total number of times the customer shopped for choice 0 of option A in the shopping history.
| *option.a.1*  | ...
| *option.a.2*  | ...
| *option.b.0*  | The total number of times the customer shopped for choice 0 of option A in the shopping history.
| *option.b.1*  | ...
| *option.a*    | The outcome for option a that is being predicted.  The value for this field comes from the purchase record.
| *option.b*    | ...

Does this work??  It does!  That wasy easy.

```{r}

# fetch the source data
data <- fetch()

# flatten the source into a form that can be used for training
shopping <- flatten.shopping.history (data)

# what do we have here?
str (shopping)
rm (data)
```

### Splitting

Split the data into a training and a hold-out test set.  Each set must be representative of the whole.  Use Caret's createDataPartition function for this.  Since this function requires a single outcome variable, create a 'product' representation of the options to allow it to do so.

```{r}

# use the 'product' attribute to split the data into representative test/train sets
add.product (shopping)
train.index <- createDataPartition (shopping$product, p = 0.8, list = F)[,1]

# create a train and test set
shopping.train <- shopping [  train.index ]
shopping.test  <- shopping [ -train.index ]

dim (shopping.test)
dim (shopping.train)
```

### Modeling

Let's first look at a naive model.  The naive model simply chooses the most popular option for each customer.

```{r}

# train the naive model
fit <- naive.model (shopping.train)

# make predictions with the naive model
shopping.test [, options.hat() := predict (fit, .SD), with = F]

# score the results
accuracy.score (shopping.test)
partial.accuracy.score (shopping.test)
```

My first attempt will focus on modeling and training each of the options (a-g) independently.  There are far fewer models in R that can, or at least make it easy, to handle multiple output in my experience.  Since we have no knowledge of what each option actually is and each may be some what unrelated (auto liability versus umbrella coverage) modeling them separately will likely help (or at least not hurt).

```{r}
fit.a <- gbm.model ("option.a", train)
fit.b <- gbm.model ("option.b", train)
fit.c <- gbm.model ("option.c", train)
fit.d <- gbm.model ("option.d", train)
fit.e <- gbm.model ("option.e", train)
fit.f <- gbm.model ("option.f", train)
fit.g <- gbm.model ("option.g", train)
```

How did the parameter tuning go?

```{r}
ggplot(fit.a)
```

Which predictors are most important?  The results seem to show that a customer shopping for a particular option is indicative of what they will eventually purchase.  Duh.

```{r}
plot (varImp (fit.a, scale = F), top = 10)
```



#### TODO: This takes care of the option elements of the shopping history, but how should the additional date-related 'day.of.week' and 'time.of.day.hours' fields be leveraged in the analysis.

#### TODO: Perhaps a difference value for each of the 'option.x.n' fields could be used.  Perhaps ones that applies a greater weight to more recent shopping history.





